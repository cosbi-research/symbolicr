% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genetic.search.R
\name{genetic.search}
\alias{genetic.search}
\title{Genetic Algorithm for non-linear formula optimization}
\usage{
genetic.search(
  complete.X.df,
  y,
  n.squares = 1,
  max.formula.len = 4,
  seed = NULL,
  fitness.fun = pe.r.squared.formula.len.fitness,
  transformations = list(log10 = function(x, z) {
     log10(0.1 + abs(z) + x)
 }, inv =
    function(x, z) {
     1/(0.1 + abs(z) + x)
 }),
  custom.abs.mins = list(),
  base.filepath = NULL,
  res.filepath = NULL,
  memoization = F,
  monitor = monitor.formula.fun,
  maxiter = 100,
  N = 2,
  K = 7,
  pcrossover = 0.2,
  popSize = 50,
  pmutation = 0.8,
  keepBest = F,
  cv.norm = F,
  best.vars.l = list()
)
}
\arguments{
\item{complete.X.df}{The dataset that contains the base variables the formula is composed of (column-wise)}

\item{y}{The independent variable to be predicted with the formula}

\item{n.squares}{The maximum order of the polynomial composition of base variables. Ex. \verb{order 0 = a}, \verb{order 1 = a*b}, \verb{order 2 = a*b*c}}

\item{max.formula.len}{The maximum number of terms in the formula}

\item{seed}{An (optional) seed for deterministic run}

\item{fitness.fun}{The function that determine the fitness of a given formula. Defaults to \code{pe.r.squared.formula.len.fitness}}

\item{transformations}{A list of potentially non-linear transformations that can be applied on top of the squares. Ex. \verb{order 0, transformation=log10 = log10.a}}

\item{custom.abs.mins}{A list of user-defined minimum values for dataset columns.}

\item{base.filepath}{Has effect only if memoization=TRUE. The path to an rDdata object containing the results of potentially multiple independent previous run.}

\item{res.filepath}{Has effect only if memoization=TRUE. The path to an rData object where the results of the current run will be stored. If it already exists, the new results will be appended.}

\item{memoization}{If TRUE test results will be stored in \code{res.filepath}}

\item{monitor}{Function that will be called on every iteration with the current solutions. Defaults to \code{monitor.formula.fun}}

\item{maxiter}{Maximum number of genetic evolution epochs}

\item{N}{The number of times the K-fold validation is repeated, shuffling the dataset row orders before each time.}

\item{K}{The number of parts the dataset is split into for K-fold cross-validation.}

\item{pcrossover}{The probability of crossover between pairs of chromosomes. Typically this is a large value and by default is set to 0.8.}

\item{popSize}{The population size, the number of formulas considered for genetic evolution.}

\item{pmutation}{The probability of mutation in a parent chromosome. Usually mutation occurs with a small probability, and by default is set to 0.1.}

\item{keepBest}{If TRUE, the value \code{best.iter} of the list returned, will contain a list of the best formulas at each evolution iteration.}

\item{cv.norm}{Normalize regressors after train-validation split in inner cross-validation loop.}

\item{best.vars.l}{A list of formulas. Each formula is an array of strings, each string is the textual representation of a formula term. Ex. \code{cur.vars.l <- list(c('a','mul.a.b'))} will test the formula \code{y ~ a + a*b}. This list is used as a starting point for genetic evolution. It may come from a-priori knowledge or by extracting the most promising results from \code{random.search}.}
}
\value{
A list with three values:
list(
best: the best formula found overall
best.iter: a list of best formulas, one for each evolution iteration
results: The output of the GA::ga function, with all the solutions, hyperparameters, etc.
)
}
\description{
Starting from an (optional) list of promising formulas,
generated with other methods such as \code{random.search},
explore combinations (crossover) and alterations (mutation)
of them in order maximize the value of the fitness function
that defaults to \code{pe.r.squared.formula.len.fitness}
}
\examples{
\dontrun{
# variables  app_charge pI_Fc patch_pos_3 patch_hyd_2
            patch_hyd_5 ens_dipole and is.monovalent
# are assumed to be in the complete.X.df input dataset
# variables starting with 'is.' suffix won't be normalized,
# because assumed to be categorical variables (0/1)
best.vars.l <- list(
 #c('log10.mul.app_charge.pI_Fc','log10.patch_pos_3',
    'mul.patch_pos.pI_Fc'),
 #c('inv.mul.patch_hyd_2.patch_hyd_2'),
 c('inv.mul.patch_hyd_5.patch_hyd_5','log10.mul.pI_Fc.pI_Fc',
   'mul.ens_dipole.is.monovalent')
)
best.finetuned <- genetic.search(
 complete.X.df,
 l.F2,
 n.squares=1,
 maxiter=1000,
 base.filepath=file.path(...),
 res.filepath=file.path(...),
 memoization=F,
 pcrossover=0.2,
 pmutation=0.8,
 seed=NULL,
 max.formula.len=4,
 keepBest=T,
 K=17,
 N=10,
 popSize = 100,
 best.vars.l = best.vars.l
)
}
}
\seealso{
random.search
}
